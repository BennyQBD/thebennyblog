---
layout: post
title: "June Progress Update"
date: 2022-06-01 12:00:00 +0000
categories: jekyll update
---

Hello everyone! It's Benny!

And today, I'm going to do my first "blog construction" update, if you will.

Basically, in the time since my last post, it's become increasingly obvious that some of the things I'd like to share with you will take a while before everything is ready to start properly sharing.

Now, some of the smaller things don't have that issue, and I'll talk about those in later in this post. But first, rather than leave you in the dark about the bigger projects, I'd like to give you a chance to see what's happening, where things are going, and how close we are to getting there.

If you're not interested in that, no problem. Just look for my next post which doesn't have "update" somewhere in the title.

Until then, here's where we're heading so far...



### What You're Looking For: Analyzing the Comments from My Last Update Video

On my most recent update video on thebennybox, I asked you to share what you were hoping to get out of my videos. Curiously, I've never had a chance to respond to those comments before now.

In fact, I've read every single comment posted on that video, organized them into a spreadsheet, and I tried to capture all the themes and ideas you all were kind enough to share with me to really understand where the community stood. Here's the results:

![My image Name](/thebennyblog/assets/images/0005_june_update/commentstats.png "All the comments from my update video organized and analyzed")

To understand this table, the "Comment" represents the general theme or idea expressed in the message you left. "Ref Count" refers to how many times that theme or idea was expressed or supported in some way throughout the entire comments section.

What I did is I looked at all the ideas you expressed interest in and compared it with the points I'm currently interested in sharing with you (such as those mentioned in my last post). I used that to choose what I thought would be the best possible match between what you're hoping to get and what I have available to share.

And that's what the colors represent in the chart: In the current project I'm preparing for you, any points I expect that project will touch on in some way are highlighted in green, points I expect it won't touch on are highlighted in red, and yellow items don't clearly land one way or the other.

In general, I'm fairly pleased I managed to find a match as good as this, and I hope you're satisfied with the areas I'm expecting to hit. The most notable miss was C++, which is a bit unfortunate. On the other hand, the current project doesn't strictly *prohibit* C++ if you want to use it or practice it yourself, it's just not going to really be explicitly taught in any way. That was about the best solution I found for hitting as many points as possible while still hitting on something meaningful I had to share (i.e. it isn't a rehash or something which I have no interest in making).

If I missed your favorite point, I'm sorry about that. But do keep in mind that this is just for my *current* project. There's a ton of things I ultimately want to do, but I can only do one project at a time, and well, *something* has be the first project. For the next project though, I'll try to prefer landing on items that were missed this time around, so hopefully I'll hit your favorite point next time.


### The Current Project in Progress

So what exactly am I preparing?

Like many of you, I'm a technology enthusiast. Especially game technology. I love it when technology that does interesting and impressive things, and I love figuring out how it works so I can make it do even more interesting and impressive things.

The thing is, in reality technology never exists in a vacuum. It's always being used towards some kind of end, and how well it achieves that end ultimately determines the worth of that technology. Incidentally, games are a great example of this effect: Even if you have the most technically incredible game in the world, no one cares about it if the game itself is awful. That's well illustrated by the history of game consoles, which is filled to bursting with technically incredible consoles that no one ever bought or played with because no one ended up making any interesting games with those consoles.

That means that technology, and especially game technology, is highly prone to a failure of the last mile. You could spend enormous amounts of time and effort to get the technology right and have it ultimately not matter if that tech isn't used in the right way. Meanwhile, someone with some mediocre hack job that barely works might end up being wildly successful solely because the right people ended up doing the right things with that mediocre tech.

That can certainly be a frustrating reality to deal with, especially if you're someone who is passionate about technology. On the other hand, this process isn't entirely outside your control. We'll probably never reach a point where we can absolutely guarantee any given project will be a success, but there's a number of things you can do to stack the odds in your favor.

These are things like:
- Have you done enough background research to know exactly what factors will decide if your project will succeed or fail before you even begin?
- Are you deliberately making your decisions in a way that optimizes for those factors, or is it more going by your gut?
- Are you resolving the biggest unknowns that impact your project's success as early as possible so you never spend more time than needed on a doomed project?
- Do you even know what success really *means* for your project?

I've done a lot of stuff over the years teaching you how to create interesting technology. But I've never done anything that goes that extra step on how to ensure that technology succeeds, and doesn't just fail at the last mile like so many other pieces of technology. That's a gap I'm interested in closing.

That's what I'm currently working on. I'd like to show you how to build technology that succeeds, with an emphasis on game technology both because it's one of my interests and because it will tie together nicely with the other material I have on game tech.


### What this project will include

I'm going to go step-by-step on exactly what to do at each stage to maximize your project's potential from the very beginning, even if you don't know what you want to build or what it means for it to succeed. And of course, this is technology oriented, so I'll also show you how to build the technology that will demand.

I intend to make this beginner friendly material which you can pick up even if you're not an expert on code or technology. Though to be clear, it definitely isn't a series on how to learn to code. You may or may not be able to pick that up along the way, but it won't be the focus of the material.

However, I'm also going to explain in detail how the concepts work and why they work the way they do. Not just "here's something you can do that will work," but "here's exactly what is working, why it works, and why other things don't work." Even the "softer" decision making aspects all have firm mathematical grounding in decision theory and information theory (in addition to the fact that they have a history of actually working in real world scenarios), so there's a lot to learn if that's your main point of interest.

Lastly, I'm planning to organize this in a way that encourages you to build and follow along with your own project rather than just doing what I do. I will be doing my own project following the same process as an example and inspiration, but really this is about helping you succeed at whatever project you're interesting in doing, and the format of the series is going to reflect that.


Or at least, all this is the vision as I currently understand it. This idea is subject to change and revision as I continue working; I may well decide there's another direction I should be taking this as I continue my research. But this is the general direction I'm thinking at the moment, it's the direction I've been working in since my last post, and I'd rather let you see how things are going right now instead of holding out forever just in case things change in the future.

That's the big thing I wanted to share with you today; I wanted to share what I'm working on and what I'm planning for the future. So far, I've been ironing out exactly what this idea should be, what's the best way to present things, and I've also been working on the example project I'll be building to demonstrate how this process works.

And yes, the example project I'm doing gets into how to build game tech from scratch, including some more advanced effects. So far, it's mostly a top-down 2D world with real-time raytraced lighting and visibility. And it's software rendered. And it's in JavaScript.

My CPU might hate me for the rest of eternity, but isnâ€™t it just so *awesome* that you can do this??

![My image Name](/thebennyblog/assets/images/0005_june_update/techdemo1.png " ")

![My image Name](/thebennyblog/assets/images/0005_june_update/techdemo2.png " ")

![My image Name](/thebennyblog/assets/images/0005_june_update/techdemo3.png " ")













### The Side Projects

You may remember that at the start of the post, I promised I had some smaller points to talk about which weren't going to be such a massive, time consuming undertaking. I'd like to briefly talk about some of those before I close out.


#### autopoly.js

One of them is an "autopoly" program I made as part of my experiments with game AI. Basically, I wanted an AI to be able to observe the player and have some capacity for recognizing patterns in the player's actions and take actions to specifically counter the player's plans.

One way this could be done would be to do basic linear regression on the player's actions. But I ended up creating a program which does polynomial regression for every degree of polynomial the data allows, then it weights that appropriately by model predictivity/complexity and finally it uses the whole ensemble to make predictions. In other words, the program automatically creates an appropriately weighted ensemble of all possible polynomial models for the dataset, hence the name "autopoly."

I ended up going this way both because it's just a generally useful tool for data analysis (step 1: load data. step 2: automatically get a high quality regression) and because it has reasonably consistent predictive and learning performance (O(n^3) cost to build the best polynomial ensemble, but n is consistently small enough in this case that it's a non-issue).

I intend to clean this up and at least release it as an open source tool for anyone interested, but preferably I'd like to do a post at some point going into more detail about this, especially some of the details on how to model this tricky case correctly, what sort of predictive performance it has, what it could be used for in the real world, how some of the concepts work, etc.

#### Color Modeling

The other point is a coding classic. A good while ago now, GIMP changed it's color picker to use an Lch color model by default. In principle, that's great news because Lch is like HSV but based on how humans actually perceive color (i.e. it's based on the CIE Lab color space), which makes it a far superior way to choose and compare colors.

In practice however, I would always go back to the inferior HSV model because Lch allows colors to go "out of gamut." In other words, it lets you select a certain color, but that color has no RGB equivalent, so you couldn't actually *use* that color. For me, that made it a very difficult tool to use because often I would want to solve issues like "Give me a blue color that's perceptually just as bright as this green", only to find I couldn't actually select said blue color because it was out of gamut.

This led me down a rabbit hole of trying to find a better way to select colors which still allowed working with perceptual variables like perceived brightness but didn't constantly give me non-existent colors.

I'd initially ended up with an HSV-ish model that used linear luma instead of variance as a good first order approximation of perceived brightness. But I eventually figured out you can apply similar logic to the logic that originally derived HSV in order to construct a conceptually similar model based on CIE Lab. That retained the key perceptual benefits of CIE Lab (i.e. brightness is perceived brightness, hue distances are perceptual hue distances and not an RGB hexagon), but nothing goes out of gamut.

Ideally, I'd like to do a future post at some point discussing how this model works. But at minimum, you can immediately look at these basic examples of how colors are in these color models and you also have access to the source code to play with them yourself.

#### CIE Lab based Hue/Saturation/Luminance Color Model

<script src="/thebennyblog/assets/scripts/canvasplot.js"></script>
<div>
    <span>Luma: </span>
    <input type="range" min="1" max="100" value="50" class="slider" id="myRange3">
</div>
<div id="hsluma3"></div>
<script src="/thebennyblog/assets/scripts/hsluma3.js"></script>

#### Linear luma based Hue/Saturation/Luminance Color Model

<div>
    <span>Luma: </span>
    <input type="range" min="1" max="100" value="50" class="slider" id="myRange2">
</div>
<div id="hsluma2"></div>
<script src="/thebennyblog/assets/scripts/hsluma2.js"></script>

Source Code (Open source, MIT License):
<br/><a href="/thebennyblog/assets/scripts/canvasplot.js">canvasplot.js</a> -- Library to plot the colors in a canvas
<br/><a href="/thebennyblog/assets/scripts/hsluma3.js">hsluma3.js</a> -- The CIE Lab based variant
<br/><a href="/thebennyblog/assets/scripts/hsluma2.js">hsluma2.js</a> -- The linear luma based variant

### In closing...

That's all I've got for the time being. I'll continue working on the Big project, probably post autopoly.js at some point, and maybe do some more detailed posts discussing that or the color models if I think it makes sense to do so.

If you have any questions, suggestions, wishes, concerns, desires, or any other thoughts at all, please feel free to leave a comment. If you ever had any doubts, all the analysis I shared at the start of this post is proof that I do indeed read and value your inputs.

<br/>
'Til then,<br/>
Benny<br/><br/>

[Leave a comment](https://github.com/BennyQBD/thebennyblog/issues/3)

---
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
